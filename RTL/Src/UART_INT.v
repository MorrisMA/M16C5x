////////////////////////////////////////////////////////////////////////////////
//
//  Copyright 2008-2013 by Michael A. Morris, dba M. A. Morris & Associates
//
//  All rights reserved. The source code contained herein is publicly released
//  under the terms and conditions of the GNU Lesser Public License. No part of
//  this source code may be reproduced or transmitted in any form or by any
//  means, electronic or mechanical, including photocopying, recording, or any
//  information storage and retrieval system in violation of the license under
//  which the source code is released.
//
//  The source code contained herein is free; it may be redistributed and/or
//  modified in accordance with the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either version 2.1 of
//  the GNU Lesser General Public License, or any later version.
//
//  The source code contained herein is freely released WITHOUT ANY WARRANTY;
//  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
//  PARTICULAR PURPOSE. (Refer to the GNU Lesser General Public License for
//  more details.)
//
//  A copy of the GNU Lesser General Public License should have been received
//  along with the source code contained herein; if not, a copy can be obtained
//  by writing to:
//
//  Free Software Foundation, Inc.
//  51 Franklin Street, Fifth Floor
//  Boston, MA  02110-1301 USA
//
//  Further, no use of this source code is permitted in any form or means
//  without inclusion of this banner prominently in any derived works.
//
//  Michael A. Morris
//  Huntsville, AL
//
////////////////////////////////////////////////////////////////////////////////

`timescale 1ns / 1ps

///////////////////////////////////////////////////////////////////////////////
// Company:         M. A. Morris & Associates
// Engineer:        Michael A. Morris
//
// Create Date:     09:37:34 06/15/2008 
/// Design Name:     Synchronous Serial Peripheral (SSP) Interface UART 
// Module Name:     ../VerilogCoponentsLib/SSP_UART/UART_INT.v
// Project Name:    Verilog Components Library
// Target Devices:  XC3S50A-4VQG100I, XC3S20A-4VQG100I, XC3S700AN-4FFG484I 
// Tool versions:   ISE 10.1i SP3 
//
// Description:
//
//  This module implements the interrupt request logic for the SSP UART. Inter-
//  rupt requests are generated for four conditions:
//
//  (1) Transmit FIFO Empty;
//  (2) Transmit FIFO Half Empty;
//  (3) Receive FIFO Half Full;
//  (4) and Receive Timeouts.
//
//  These four conditions are used as the interrupt sources. Interrupts are not
//  generated for CTS Change-Of-State and Rx Errors because that information is
//  either not useful (CTS) or reported for each received character (RERR). The
//  interrupt flags generated by this module must be combined externally to form
//  an interrupt request to the client.
//
//  The interrupt flags will be reset/cleared as indicated below except when the
//  rst/clr pulse is coincident with the pulse which would set the flag, the 
//  flag remains set so that the new assertion pulse is not lost. 
//
//  There remains a small probability that the second pulse may be lost. This
//  can be remedied by stretching the setting pulse to a width equal to the un-
//  certainty between the setting and resetting pulses: approximately 4 clock
//  cycles when re1ce modules are used to generate the Clr_Int pulse.
//
// Dependencies: redet.v, fedet.v
//
// Revision History:
//
//  0.01    08E15   MAM     File Created
//
//  1.00    08G24   MAM     Corrected the reset function for the four flags.
//                          The previous implementation would not reset or
//                          allow the flags to be initialized to the "Off"
//                          state. Added the RF_EF as a port, and added a 
//                          rising edge detector on the RF_EF to reset the
//                          RTO flag.
//
//  1.10    08H10   MAM     Changed the reset logic for the iTFE and iTHF
//                          so that they remain set until read by the host.
//
//  2.00    11B06   MAM     Converted to Verilog 2001.
//
//  2.10    13G12   MAM     Corrected an error regarding the clearing of the
//                          interrupt flag bits. Required a change to the
//                          USR in module SSP_UART: USR needed to be registered
//                          whenever a read operation was performed. The result-
//                          ing difference between the interrupt flags in the
//                          UART clock domain, and the corresponding USR bits in
//                          the SCK domain preserve the interrupt bits until the
//                          user has had a chance to read the interrupt flag.
//                          Also renamed to iRDA flag to iRHF which is more
//                          appropriate since the flag is set only on the rising
//                          edge of the RX FIFO Half Full flag.
//
// Additional Comments: 
//
//      The interrupt flags are set and reset under a variety of conditions.
// 
//      iTFE -  Set on the rising edge of the Transmit FIFO Empty Flag (TF_EF)
//              Rst on Clr_Int.
//
//      iTHE -  Set on the falling edge of Transmit FIFO Half Full (TF_HF) 
//              Rst on Clr_Int.
//
//      iRHF -  Set on the rising edge of Receive FIFO Half Full (RF_HF)
//              Rst on Clr_Int or on the falling edge of RF_HF.
//
//      iRTO -  Set on the rising edge of RTO
//              Rst on Clr_Int.
//
///////////////////////////////////////////////////////////////////////////////

module UART_INT(
    input   Rst,                    // Reset
    input   Clk,                    // Clock
    
    input   TF_HF,                  // Transmit FIFO Half-Full Flag
    input   TF_EF,                  // Transmit FIFO Empty Flag
    input   RF_HF,                  // Receive FIFO Half-Full Flag
    input   RF_EF,                  // Receive FIFO Empty Flag
    
    input   RTO,                    // Receiver Timeout
    
    input   Clr_Int,                // Clear interrupt pulse
    input   [3:0] USR,              // USR: {iRTO, iRHF, iTHE, iTFE}    
    
    output  reg iTFE,               // Interrupt - Tx FIFO Empty
    output  reg iTHE,               // Interrupt - Tx FIFO Half Empty
    output  reg iRHF,               // Interrupt - Rx FIFO Half Full
    output  reg iRTO                // Interrupt - Receive Time Out Detected
);

///////////////////////////////////////////////////////////////////////////////
//
//  Local Signal Declarations
//

    wire    reTF_EF, feTF_HF;
    wire    reRF_HF, feRF_HF, reRF_EF;
    wire    reRTO;
    
///////////////////////////////////////////////////////////////////////////////
//
//  Implementation
//

redet   RE1 (.rst(Rst), .clk(Clk), .din(TF_EF), .pls(reTF_EF));
fedet   FE1 (.rst(Rst), .clk(Clk), .din(TF_HF), .pls(feTF_HF));

redet   RE2 (.rst(Rst), .clk(Clk), .din(RF_HF), .pls(reRF_HF));
fedet   FE2 (.rst(Rst), .clk(Clk), .din(RF_HF), .pls(feRF_HF));
redet   RE3 (.rst(Rst), .clk(Clk), .din(RF_EF), .pls(reRF_EF));

redet   RE4 (.rst(Rst), .clk(Clk), .din(RTO),   .pls(reRTO));

///////////////////////////////////////////////////////////////////////////////
//
//  Transmit FIFO Empty Interrupt Flag
//

assign Rst_iTFE = Rst | (iTFE & Clr_Int & USR[0]);

always @(posedge Clk or posedge reTF_EF)
begin
    if(reTF_EF)
        iTFE <= #1 1;
    else if(Rst_iTFE)
        iTFE <= #1 reTF_EF;
end

///////////////////////////////////////////////////////////////////////////////
//
//  Transmit FIFO Half Empty Interrupt Flag
//

assign Rst_iTHE = Rst | (iTHE & Clr_Int & USR[1]);

always @(posedge Clk or posedge feTF_HF)
begin
    if(feTF_HF)
        iTHE <= #1 1;
    else if(Rst_iTHE)
        iTHE <= #1 feTF_HF;
end

///////////////////////////////////////////////////////////////////////////////
//
//  Receive Data Available Interrupt Flag
//

assign Rst_iRHF = Rst | (iRHF & (Clr_Int | feRF_HF | reRF_EF) & USR[2]);

always @(posedge Clk or posedge reRF_HF)
begin
    if(reRF_HF)
        iRHF <= #1 1;
    else if(Rst_iRHF)
        iRHF <= #1 reRF_HF;
end

///////////////////////////////////////////////////////////////////////////////
//
//  Receive Timeout Interrupt Flag
//

assign Rst_iRTO = Rst | (iRTO & Clr_Int & USR[3]);

always @(posedge Clk or posedge reRTO)
begin
    if(reRTO)
        iRTO <= #1 1;
    else if(Rst_iRTO)
        iRTO <= #1 reRTO;
end

endmodule
